{"version":3,"sources":["webpack:///./node_modules/mescroll.js/mescroll.vue?0bc1","webpack:///./node_modules/mescroll.js/mescroll.vue?28c7","webpack:///node_modules/mescroll.js/mescroll.vue","webpack:///./node_modules/mescroll.js/mescroll.vue?e3ae","webpack:///./node_modules/mescroll.js/mescroll.vue","webpack:///./node_modules/mescroll.js/mescroll.min.js"],"names":["_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_css_loader_index_js_ref_6_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_lib_index_js_ref_6_oneOf_1_2_cache_loader_dist_cjs_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_mescroll_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_css_loader_index_js_ref_6_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_lib_index_js_ref_6_oneOf_1_2_cache_loader_dist_cjs_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_mescroll_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default","n","render","_vm","this","_h","$createElement","_c","_self","ref","staticClass","_t","staticRenderFns","mescrollvue_type_script_lang_js_","name","data","mescroll","lastScrollTop","lastBounce","props","up","Object","down","mounted","mescroll_min_default","a","$refs","$emit","window","test","methods","beforeRouteEnter","_this","setScrollTop","setTimeout","setTopBtnFadeDuration","setBounce","beforeRouteLeave","getScrollTop","hideTopBtn","optUp","isBounce","mescroll_js_mescrollvue_type_script_lang_js_","component","componentNormalizer","options","__file","__webpack_exports__","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","definition","call","exports","module","undefined","MeScroll","mescrollId","me","version","isScrollBody","scrollDom","document","body","getDomById","u","navigator","userAgent","isIOS","match","isPC","orientation","isAndroid","indexOf","os","ios","pc","android","isDownScrolling","isUpScrolling","hasDownCallback","callback","initDownScroll","initUpScroll","optDown","use","auto","autoShowLoading","triggerDownScroll","isUpAutoLoad","triggerUpScroll","prototype","extendDownScroll","extend","isLock","isBoth","offset","inOffsetRate","outOffsetRate","bottomOffset","minAngle","hardwareClass","mustToTop","warpId","warpClass","resetClass","textInOffset","textOutOffset","textLoading","htmlContent","inited","downwarp","downTipDom","getElementsByClassName","downProgressDom","inOffset","innerHTML","classList","remove","outOffset","onMoving","rate","downHight","progress","style","webkitTransform","transform","beforeLoading","showLoading","add","afterLoading","resetUpScroll","extendUpScroll","page","num","size","time","noMoreSize","toTop","src","html","showClass","hideClass","fadeDuration","duration","supportTap","btnClick","loadFull","delay","empty","icon","tip","btntext","clearId","clearEmptyId","htmlLoading","htmlNodata","upwarp","showNoMore","onScroll","scrollbar","barClass","lazyLoad","attr","userOption","defaultOption","key","touchstartEvent","e","isScrollTo","preventDefault","startPoint","getPoint","lastPoint","maxTouchmoveY","getBodyHeight","inTouchend","scrollTop","isKeepTop","addEventListener","touchmoveEvent","passive","ondragstart","curPoint","moveY","y","console","log","x","Math","abs","z","sqrt","angle","asin","PI","touchendEvent","diff","movetype","isMoveDown","webkitOverflowScrolling","isSetScrollAuto","height","scrollHeight","getScrollHeight","clientHeight","getClientHeight","toBottom","hasNext","removeEventListener","createElement","className","downparent","appendChild","insertBefore","firstChild","cancelable","defaultPrevented","touches","pageX","clientX","pageY","clientY","showDownScroll","endDownScroll","endScroll","lockDownScroll","upparent","preScrollY","lazyStartTime","Date","getTime","lazyTag","scrollEvent","isUp","optTop","showTopBtn","curTime","lazyTimer","clearTimeout","bounceTouchmove","el","target","isPrevent","cls","contains","curX","curY","preWinX","preWinY","parentNode","showUpScroll","visibility","display","hideUpScroll","displayAble","upProgressDom","endUpScroll","isShowNoMore","isShowLoading","prePageNum","prePageTime","removeEmpty","clearDataList","setPageNum","setPageSize","listId","listDom","endByPage","dataSize","totalPage","systime","endSuccess","endBySize","totalSize","loadSize","pageNum","pageSize","showEmpty","allDataSize","endErr","lockUpScroll","optEmpty","emptyWarp","str","emptyDom","emptyBtn","stopPropagation","onclick","removeChild","topBtnShow","warpDom","toTopBtn","disToTop","scrollTo","animationDuration","webkitAnimationDuration","t","star","end","maxY","getStep","step","count","i","timer","setInterval","clearInterval","domArr","querySelectorAll","len","length","dom","getAttribute","isInSee","imgurl","temp","Image","onload","tagName","backgroundImage","removeAttribute","onerror","onabort","setAttribute","topDom","getOffsetTop","topSee","bottomDom","offsetHeight","bottomSee","top","offsetTop","parent","offsetParent","clientTop","compatMode","documentElement","getToBottom","id","getElementById","nodeType","error","destroy"],"mappings":"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","file":"js/index~match~match_detail~message_good~message_reply~news_detail~scratc.c4ae8ff2.js","sourcesContent":["import mod from \"-!../mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../css-loader/index.js??ref--6-oneOf-1-1!../vue-loader/lib/loaders/stylePostLoader.js!../postcss-loader/lib/index.js??ref--6-oneOf-1-2!../cache-loader/dist/cjs.js??ref--0-0!../vue-loader/lib/index.js??vue-loader-options!./mescroll.vue?vue&type=style&index=0&lang=css&\"; export default mod; export * from \"-!../mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../css-loader/index.js??ref--6-oneOf-1-1!../vue-loader/lib/loaders/stylePostLoader.js!../postcss-loader/lib/index.js??ref--6-oneOf-1-2!../cache-loader/dist/cjs.js??ref--0-0!../vue-loader/lib/index.js??vue-loader-options!./mescroll.vue?vue&type=style&index=0&lang=css&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:\"mescroll\",staticClass:\"mescroll\"},[_c('div',[_vm._t(\"default\")],2)])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n  <div ref=\"mescroll\" class=\"mescroll\">\n    <div>\n      <slot></slot>\n    </div>\n  </div>\n</template>\n\n<script>\n// 引入mescroll.min.js和mescroll.min.css\nimport MeScroll from 'mescroll.js'\nimport 'mescroll.js/mescroll.min.css'\n\nexport default {\n  name: 'MeScrollVue',\n  data: function () {\n    return {\n      mescroll: null,\n      lastScrollTop: 0, // 路由切换时滚动条的位置\n      lastBounce: null // 路由切换时是否禁止ios回弹\n    }\n  },\n  props: {\n    up: Object,\n    down: Object\n  },\n  mounted: function () {\n    this.mescroll = new MeScroll(this.$refs.mescroll, {\n      up: this.up,\n      down: this.down\n    })\n    this.$emit('init', this.mescroll) // init回调mescroll对象\n    window.test= this.$refs.mescroll;\n    // this.$refs.mescroll.unbind('')\n  },\n  methods: {\n    beforeRouteEnter () {\n      if (this.mescroll) {\n        // 滚动到之前列表的位置\n        if (this.lastScrollTop) {\n          this.mescroll.setScrollTop(this.lastScrollTop)\n          setTimeout(() => { // 需延时,因为setScrollTop内部会触发onScroll,可能会渐显回到顶部按钮\n            this.mescroll.setTopBtnFadeDuration(0) // 设置回到顶部按钮显示时无渐显动画\n          }, 16)\n        }\n        // 恢复到之前设置的isBounce状态\n        if (this.lastBounce != null) this.mescroll.setBounce(this.lastBounce)\n      }\n    },\n    beforeRouteLeave () {\n      if (this.mescroll) {\n        this.lastScrollTop = this.mescroll.getScrollTop() // 记录当前滚动条的位置\n        this.mescroll.hideTopBtn(0) // 隐藏回到顶部按钮,无渐隐动画\n        this.lastBounce = this.mescroll.optUp.isBounce // 记录当前是否禁止ios回弹\n        this.mescroll.setBounce(true) // 允许bounce\n      }\n    }\n  }\n}\n</script>\n\n<style>\n</style>\n","import mod from \"-!../cache-loader/dist/cjs.js??ref--12-0!../thread-loader/dist/cjs.js!../babel-loader/lib/index.js!../cache-loader/dist/cjs.js??ref--0-0!../vue-loader/lib/index.js??vue-loader-options!./mescroll.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../cache-loader/dist/cjs.js??ref--12-0!../thread-loader/dist/cjs.js!../babel-loader/lib/index.js!../cache-loader/dist/cjs.js??ref--0-0!../vue-loader/lib/index.js??vue-loader-options!./mescroll.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./mescroll.vue?vue&type=template&id=288df709&\"\nimport script from \"./mescroll.vue?vue&type=script&lang=js&\"\nexport * from \"./mescroll.vue?vue&type=script&lang=js&\"\nimport style0 from \"./mescroll.vue?vue&type=style&index=0&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"mescroll.vue\"\nexport default component.exports","/*! mescroll -- 精致的下拉刷新和上拉加载js框架  ( a great JS framework for pull-refresh and pull-up-loading )\n * version 1.4.0\n * 2018-11-25\n * author: wenju < mescroll@qq.com > 文举\n * *\n * 官网:  http://www.mescroll.com\n * 动态:  https://github.com/mescroll/mescroll/releases\n * 问答:  http://www.mescroll.com/qa.html\n * issues:  https://github.com/mescroll/mescroll/issues\n * QQ交流群: 633126761\n */\n(function (name, definition) {\n  if (typeof define === 'function') {\n    // AMD环境或CMD环境\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    // 定义为普通Node模块\n    module.exports = definition();\n  } else {\n    // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象\n    this[name] = definition();\n  }\n})('MeScroll', function () {\n  var MeScroll = function (mescrollId, options) {\n    var me = this;\n    me.version = '1.4.0'; // mescroll版本号\n    me.isScrollBody = (!mescrollId || mescrollId === 'body'); // 滑动区域是否为body\n    me.scrollDom = me.isScrollBody ? document.body : me.getDomById(mescrollId); // MeScroll的滑动区域\n    if (!me.scrollDom) return;\n\n    me.options = options || {}; // 配置\n\n    var u = navigator.userAgent;\n    var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); // 是否为ios设备\n    var isPC = typeof window.orientation === 'undefined'; // 是否为PC端\n    var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;// 是否为android端\n\n    me.os = {\n      ios: isIOS,\n      pc: isPC,\n      android: isAndroid\n    }\n\n    me.isDownScrolling = false; // 是否在执行下拉刷新的回调\n    me.isUpScrolling = false; // 是否在执行上拉加载的回调\n    var hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\n\n    // 初始化下拉刷新\n    me.initDownScroll();\n    // 初始化上拉加载,则初始化\n    me.initUpScroll();\n\n    // 自动加载\n    setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      // 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\n      if (me.optDown.use && me.optDown.auto && hasDownCallback) {\n        if (me.optDown.autoShowLoading) {\n          me.triggerDownScroll(); // 显示下拉进度,执行下拉回调\n        } else {\n          me.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\n        }\n      }\n      // 自动触发上拉加载\n      me.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\n    }, 30); // 需让me.optDown.inited和me.optUp.inited先执行\n  }\n\n  /* 配置参数:下拉刷新 */\n  MeScroll.prototype.extendDownScroll = function (optDown) {\n    // 下拉刷新的配置\n    MeScroll.extend(optDown, {\n      use: true, // 是否启用下拉刷新; 默认true\n      auto: true, // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\n      autoShowLoading: false, // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\n      isLock: false, // 是否锁定下拉刷新,默认false;\n      isBoth: false, // 下拉刷新时,如果滑动到列表底部是否可以同时触发上拉加载;默认false,两者不可同时触发;\n      offset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\n      inOffsetRate: 1, // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n      outOffsetRate: 0.2, // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\n      bottomOffset: 20, // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\n      minAngle: 45, // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\n      hardwareClass: 'mescroll-hardware', // 硬件加速样式,解决部分手机闪屏或动画不流畅的问题\n      mustToTop: false, // 是否滚动条必须在顶部,才可以下拉刷新.默认false. 当您发现下拉刷新会闪白屏时,设置true即可修复.\n      warpId: null, // 可配置下拉刷新的布局添加到指定id的div;默认不配置,默认添加到mescrollId\n      warpClass: 'mescroll-downwarp', // 下拉刷新的布局容器样式,参见mescroll.css\n      resetClass: 'mescroll-downwarp-reset', // 下拉刷新高度重置的动画,参见mescroll.css\n      textInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本\n      textOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本\n      textLoading: '加载中 ...', // 加载中的提示文本\n      htmlContent: '<p class=\"downwarp-progress\"></p><p class=\"downwarp-tip\"></p>', // 布局内容\n      inited: function (mescroll, downwarp) {\n        // 下拉刷新初始化完毕的回调\n        mescroll.downTipDom = downwarp.getElementsByClassName('downwarp-tip')[0];\n        mescroll.downProgressDom = downwarp.getElementsByClassName('downwarp-progress')[0];\n      },\n      inOffset: function (mescroll) {\n        // 下拉的距离进入offset范围内那一刻的回调\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textInOffset;\n        if (mescroll.downProgressDom) mescroll.downProgressDom.classList.remove('mescroll-rotate');\n      },\n      outOffset: function (mescroll) {\n        // 下拉的距离大于offset那一刻的回调\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textOutOffset;\n      },\n      onMoving: function (mescroll, rate, downHight) {\n        // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\n        if (mescroll.downProgressDom) {\n          var progress = 360 * rate;\n          mescroll.downProgressDom.style.webkitTransform = 'rotate(' + progress + 'deg)';\n          mescroll.downProgressDom.style.transform = 'rotate(' + progress + 'deg)';\n        }\n      },\n      beforeLoading: function (mescroll, downwarp) {\n        // 准备触发下拉刷新的回调\n        return false; // 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\n      },\n      showLoading: function (mescroll) {\n        // 显示下拉刷新进度的回调\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textLoading;\n        if (mescroll.downProgressDom) mescroll.downProgressDom.classList.add('mescroll-rotate');\n      },\n      afterLoading: function (mescroll) {\n        // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\n        return 0\n      },\n      callback: function (mescroll) {\n        // 下拉刷新的回调;默认重置上拉加载列表为第一页\n        mescroll.resetUpScroll();\n      }\n    })\n  }\n\n  /* 配置参数:上拉加载 */\n  MeScroll.prototype.extendUpScroll = function (optUp) {\n    // 是否为PC端,如果是scrollbar端,默认自定义滚动条\n    var isPC = this.os.pc;\n    // 上拉加载的配置\n    MeScroll.extend(optUp, {\n      use: true, // 是否启用上拉加载; 默认true\n      auto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\n      isLock: false, // 是否锁定上拉加载,默认false;\n      isBoth: false, // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认false,两者不可同时触发;\n      isBounce: true, // 是否允许ios的bounce回弹;默认true,允许; 如果设置为false,则除了mescroll, mescroll-touch, mescroll-touch-x, mescroll-touch-y能够接收touchmove事件,其他部分均无法滑动,能够有效禁止bounce\n      callback: null, // 上拉加载的回调;function(page,mescroll){ }\n      page: {\n        num: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\n        size: 10, // 每页数据的数量\n        time: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\n      },\n      noMoreSize: 5, // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\n      offset: 100, // 列表滚动到距离底部小于100px,即可触发上拉加载的回调\n      toTop: {\n        // 回到顶部按钮,需配置src才显示\n        warpId: null, // 父布局的id; 默认添加在body中\n        src: null, // 图片路径,默认null;\n        html: null, // html标签内容,默认null; 如果同时设置了src,则优先取src\n        offset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000\n        warpClass: 'mescroll-totop', // 按钮样式,参见mescroll.css\n        showClass: 'mescroll-fade-in', // 显示样式,参见mescroll.css\n        hideClass: 'mescroll-fade-out', // 隐藏样式,参见mescroll.css\n        fadeDuration: 0.5, // 回到顶部按钮的显示隐藏动画时长,默认0.5秒. (注意:showClass和hideClass设置的动画时长不会生效.)\n        duration: 300, // 回到顶部的动画时长,默认300ms\n        supportTap: false, // 如果您的运行环境支持tap,则可配置true;\n        btnClick: null // 点击按钮的回调; 小提示:如果在回调里return true,将不执行回到顶部的操作.\n      },\n      loadFull: {\n        use: false, // 列表数据过少,不足以滑动触发上拉加载,是否自动加载下一页,直到满屏或者无更多数据为止;默认false,因为可通过调高page.size避免这个情况\n        delay: 500 // 延时执行的毫秒数; 延时是为了保证列表数据或占位的图片都已初始化完成,且下拉刷新上拉加载中区域动画已执行完毕;\n      },\n      empty: {\n        // 列表第一页无任何数据时,显示的空提示布局; 需配置warpId或clearEmptyId才生效;\n        warpId: null, // 父布局的id; 如果此项有值,将不使用clearEmptyId的值;\n        icon: null, // 图标路径\n        tip: '暂无相关数据~', // 提示\n        btntext: '', // 按钮\n        btnClick: null, // 点击按钮的回调\n        supportTap: false // 如果您的运行环境支持tap,则可配置true;\n      },\n      clearId: null, // 加载第一页时需清空数据的列表id; 如果此项有值,将不使用clearEmptyId的值;\n      clearEmptyId: null, // 相当于同时设置了clearId和empty.warpId; 简化写法;默认null; 注意vue中不能配置此项\n      hardwareClass: 'mescroll-hardware', // 硬件加速样式,使上拉动画流畅\n      warpId: null, // 可配置上拉加载的布局添加到指定id的div;默认不配置,默认添加到mescrollId\n      warpClass: 'mescroll-upwarp', // 上拉加载的布局容器样式\n      htmlLoading: '<p class=\"upwarp-progress mescroll-rotate\"></p><p class=\"upwarp-tip\">加载中..</p>', // 上拉加载中的布局\n      htmlNodata: '<p class=\"upwarp-nodata\">-- END --</p>', // 无数据的布局\n      inited: function (mescroll, upwarp) {\n        // 初始化完毕的回调,可缓存dom 比如 mescroll.upProgressDom = upwarp.getElementsByClassName(\"upwarp-progress\")[0];\n      },\n      showLoading: function (mescroll, upwarp) {\n        // 上拉加载中.. mescroll.upProgressDom.style.display = \"block\" 不通过此方式显示,因为ios快速滑动到底部,进度条会无法及时渲染\n        upwarp.innerHTML = mescroll.optUp.htmlLoading;\n      },\n      showNoMore: function (mescroll, upwarp) {\n        // 无更多数据\n        upwarp.innerHTML = mescroll.optUp.htmlNodata;\n      },\n      onScroll: null, // 列表滑动监听,默认null; 例如 onScroll: function(mescroll, y, isUp){ }; //y为列表当前滚动条的位置; isUp=true向上滑,isUp=false向下滑\n      scrollbar: {\n        use: isPC, // 默认只在PC端自定义滚动条样式\n        barClass: 'mescroll-bar'\n      },\n      lazyLoad: {\n        use: false, // 是否开启懒加载,默认false\n        attr: 'imgurl', // 网络图片地址的属性名 (图片加载成功会自动移除改属性): <img imgurl='网络图  src='占位图''/>\n        showClass: 'mescroll-lazy-in', // 显示样式,参见mescroll.css\n        delay: 500, // 列表滚动的过程中每500ms检查一次图片是否在可视区域,如果在可视区域则加载图片\n        offset: 200 // 超出可视区域200px的图片仍可触发懒加载,目的是提前加载部分图片\n      }\n    })\n  }\n\n  /* 配置参数 */\n  MeScroll.extend = function (userOption, defaultOption) {\n    if (!userOption) return defaultOption;\n    for (var key in defaultOption) {\n      if (userOption[key] == null) {\n        userOption[key] = defaultOption[key];\n      } else if (typeof userOption[key] === 'object') {\n        MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\n      }\n    }\n    return userOption;\n  }\n\n  /* -------初始化下拉刷新------- */\n  MeScroll.prototype.initDownScroll = function () {\n    var me = this;\n\n    // 配置参数\n    me.optDown = me.options.down || {};\n\n    // 具体参数配置\n    me.extendDownScroll(me.optDown);\n\n    // 鼠标或手指的按下事件\n    me.touchstartEvent = function (e) {\n      if (me.isScrollTo) me.preventDefault(e); // 如果列表执行滑动事件,则阻止事件,优先执行scrollTo方法\n\n      me.startPoint = me.getPoint(e); // 记录起点\n      me.lastPoint = me.startPoint; // 重置上次move的点\n\n      me.maxTouchmoveY = me.getBodyHeight() - me.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\n      me.inTouchend = false; // 标记不是touchend\n      var scrollTop = me.getScrollTop();// 滚动条的位置\n      me.isKeepTop = scrollTop === 0; // 标记滚动条起点为0\n      if (me.os.pc && scrollTop <= 0) {\n        // 在顶部给PC端添加move事件\n        me.scrollDom.addEventListener('mousemove', me.touchmoveEvent, {\n          passive: false\n        });\n        document.ondragstart = function () { // 在顶部禁止PC端拖拽图片,避免与下拉刷新冲突\n          return false;\n        }\n      }\n    }\n\n    me.scrollDom.addEventListener('mousedown', me.touchstartEvent); // PC端鼠标事件\n    me.scrollDom.addEventListener('touchstart', me.touchstartEvent); // 移动端手指事件\n\n    // 鼠标或手指的滑动事件\n    me.touchmoveEvent = function (e) {\n      if (!me.startPoint) return;\n\n      var scrollTop = me.getScrollTop(); // 当前滚动条的距离\n      if (scrollTop > 0) me.isKeepTop = false; // 在移动过程中,只要滚动条有一次大于0,则标记false\n      var curPoint = me.getPoint(e); // 当前点\n\n      var moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\n\n      // 向下拉\n      if (moveY > 0) {\n      \tconsole.log('向下拉')\n        // 在顶部\n        if (scrollTop <= 0) {\n          //me.preventDefault(e); // 阻止浏览器默认的滚动,避免触发bounce\n\n          // 可下拉的条件\n          if (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || (me.isUpScrolling && me.optUp.isBoth))) {\n            if (me.optDown.mustToTop && !me.isKeepTop) return; // 是否配置了必须在顶部才可以下拉\n\n            // 下拉的角度是否在配置的范围内\n            var x = Math.abs(me.lastPoint.x - curPoint.x);\n            var y = Math.abs(me.lastPoint.y - curPoint.y);\n            var z = Math.sqrt(x * x + y * y);\n            if (z !== 0) {\n              var angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\n              if (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\n            }\n\t\t\t\t\t\t\n            // 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\n            if (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\n              me.inTouchend = true; // 标记执行touchend\n              me.touchendEvent(); // 提前触发touchend\n              return;\n            }\n\n            var diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\n            if (!me.downHight) me.downHight = 0; // 下拉区域的高度\n            // 下拉距离  < 指定距离\n            if (me.downHight < me.optDown.offset) {\n              if (me.movetype !== 1) {\n                me.movetype = 1; // 加入标记,保证只执行一次\n                me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\n                me.downwarp.classList.remove(me.optDown.resetClass); // 移除高度重置的动画\n                me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n                if (me.os.ios && !me.isKeepTop) { // 下拉过程中,滚动条一直在顶部的,则不必取消回弹,否则会闪白屏\n                  me.scrollDom.classList.add(me.optDown.hardwareClass); // 开启硬件加速,解决iOS下拉因隐藏进度条而闪屏的问题\n                  me.scrollDom.style.webkitOverflowScrolling = 'auto'; // 取消列表回弹效果,避免与下面me.downwarp.style.height混合,而导致界面抖动闪屏\n                  me.isSetScrollAuto = true; // 标记设置了webkitOverflowScrolling为auto\n                }\n              }\n              me.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\n\n              // 指定距离  <= 下拉距离\n            } else {\n              if (me.movetype !== 2) {\n                me.movetype = 2; // 加入标记,保证只执行一次\n                me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\n                me.downwarp.classList.remove(me.optDown.resetClass); // 移除高度重置的动画\n                me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\n                if (me.os.ios && !me.isKeepTop) { // 下拉过程中,滚动条一直在顶部的,则不必取消回弹,否则会闪白屏\n                  me.scrollDom.classList.add(me.optDown.hardwareClass); // 开启硬件加速,解决iOS下拉因隐藏进度条而闪屏的问题\n                  me.scrollDom.style.webkitOverflowScrolling = 'auto'; // 取消列表回弹效果,避免与下面me.downwarp.style.height混合,而导致界面抖动闪屏\n                  me.isSetScrollAuto = true; // 标记设置了webkitOverflowScrolling为auto\n                }\n              }\n              if (diff > 0) { // 向下拉\n                me.downHight += diff * me.optDown.outOffsetRate; // 越往下,高度变化越小\n              } else { // 向上收\n                me.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\n              }\n            }\n\n            me.downwarp.style.height = me.downHight + 'px'; // 实时更新下拉区域高度\n            var rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\n            me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\n          }\n        }\n\n        // 向上拉\n      } else if (moveY < 0) {\n      \tconsole.log('向上拉')\n        var scrollHeight = me.getScrollHeight(); // 滚动内容的高度\n        var clientHeight = me.getClientHeight(); // 滚动容器的高度\n        var toBottom = scrollHeight - clientHeight - scrollTop; // 滚动条距离底部的距离\n\n        // 如果在底部,则阻止浏览器默认事件\n        if (!me.optUp.isBounce && toBottom <= 0) me.preventDefault(e);\n\n        // 如果不满屏或者已经在底部,无法触发scroll事件,此时需主动触发上拉回调\n        if (me.optUp.use && !me.optUp.isLock && me.optUp.hasNext && !me.isUpScrolling && (!me.isDownScrolling || (me.isDownScrolling && me.optDown.isBoth)) && (clientHeight + me.optUp.offset >= scrollHeight || toBottom <= 0)) {\n          me.triggerUpScroll();\n        }\n      }\n\n      me.lastPoint = curPoint; // 记录本次移动的点\n    }\n\n    // 移动端手指的滑动事件\n    me.scrollDom.addEventListener('touchmove', me.touchmoveEvent, {\n      passive: false\n    });\n\n    // 鼠标或手指的离开事件\n    me.touchendEvent = function () {\n      // 如果下拉区域高度已改变,则需重置回来\n      if (me.optDown.use && me.isMoveDown) {\n        if (me.downHight >= me.optDown.offset) {\n          // 符合触发刷新的条件\n          me.triggerDownScroll();\n        } else {\n          // 不符合的话 则重置\n          me.downwarp.classList.add(me.optDown.resetClass); // 加入高度重置的动画,过渡平滑\n          me.downHight = 0;\n          me.downwarp.style.height = 0;\n        }\n        if (me.isSetScrollAuto) {\n          me.scrollDom.style.webkitOverflowScrolling = 'touch';\n          me.scrollDom.classList.remove(me.optDown.hardwareClass);\n          me.isSetScrollAuto = false;\n        }\n        me.movetype = 0;\n        me.isMoveDown = false;\n      }\n\n      if (me.os.pc) {\n        me.scrollDom.removeEventListener('mousemove', me.touchmoveEvent); // 移除pc端的move事件\n        document.ondragstart = function () { // 解除PC端禁止拖拽图片\n          return true;\n        }\n      }\n    }\n\n    me.scrollDom.addEventListener('mouseup', me.touchendEvent); // PC端鼠标抬起事件\n    me.scrollDom.addEventListener('mouseleave', me.touchendEvent); // PC端鼠标离开事件\n    me.scrollDom.addEventListener('touchend', me.touchendEvent); // 移动端手指事件\n    me.scrollDom.addEventListener('touchcancel', me.touchendEvent); // 移动端系统停止跟踪触摸\n\n    // 在页面中加入下拉布局\n    if (me.optDown.use) {\n      me.downwarp = document.createElement('div');\n      me.downwarp.className = me.optDown.warpClass;\n      me.downwarp.innerHTML = '<div class=\"downwarp-content\">' + me.optDown.htmlContent + '</div>';\n      var downparent = me.optDown.warpId ? me.getDomById(me.optDown.warpId) : me.scrollDom;\n      if (me.optDown.warpId && downparent) {\n        downparent.appendChild(me.downwarp);\n      } else {\n        if (!downparent) downparent = me.scrollDom;\n        downparent.insertBefore(me.downwarp, me.scrollDom.firstChild);\n      }\n      // 初始化完毕的回调\n      setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n        me.optDown.inited(me, me.downwarp);\n      }, 0)\n    }\n  }\n\n  /* 阻止浏览器默认滚动事件 */\n  MeScroll.prototype.preventDefault = function (e) {\n    // cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\n    if (e && e.cancelable && !e.defaultPrevented) e.preventDefault()\n  }\n\n  /* 根据点击滑动事件获取第一个手指的坐标 */\n  MeScroll.prototype.getPoint = function (e) {\n    return {\n      x: e.touches ? e.touches[0].pageX : e.clientX,\n      y: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  }\n\n  /* 触发下拉刷新 */\n  MeScroll.prototype.triggerDownScroll = function () {\n    if (!this.optDown.beforeLoading(this, this.downwarp)) { // 准备触发下拉的回调,return true则处于完全自定义状态;默认return false;\n      this.showDownScroll(); // 下拉刷新中...\n      this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\n    }\n  }\n\n  /* 显示下拉进度布局 */\n  MeScroll.prototype.showDownScroll = function () {\n    this.isDownScrolling = true; // 标记下拉中\n    this.optDown.showLoading(this); // 下拉刷新中...\n    this.downHight = this.optDown.offset; // 更新下拉区域高度\n    this.downwarp.classList.add(this.optDown.resetClass); // 加入高度重置的动画,过渡平滑\n    this.downwarp.style.height = this.optDown.offset + 'px'; // 调整下拉区域高度\n  }\n\n  /* 结束下拉刷新 */\n  MeScroll.prototype.endDownScroll = function () {\n    var me = this;\n    // 结束下拉刷新的方法\n    var endScroll = function () {\n      me.downHight = 0;\n      me.downwarp.style.height = 0;\n      me.isDownScrolling = false;\n      if (me.downProgressDom) me.downProgressDom.classList.remove('mescroll-rotate');\n    }\n    // 结束下拉刷新时的回调\n    var delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\n    if (typeof delay === 'number' && delay > 0) {\n      setTimeout(endScroll, delay);\n    } else {\n      endScroll();\n    }\n  }\n\n  /* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\n  MeScroll.prototype.lockDownScroll = function (isLock) {\n    if (isLock == null) isLock = true;\n    this.optDown.isLock = isLock;\n  }\n\n  /* -------初始化上拉加载------- */\n  MeScroll.prototype.initUpScroll = function () {\n    var me = this;\n\n    // 配置参数\n    me.optUp = me.options.up || {\n      use: false\n    };\n\n    // 具体参数配置\n    me.extendUpScroll(me.optUp);\n\n    // 自定义滚动条 (默认只在PC端设置)\n    if (me.optUp.scrollbar.use) me.scrollDom.classList.add(me.optUp.scrollbar.barClass);\n\n    // 不允许ios的bounce时,需禁止webview的touchmove事件\n    if (!me.optUp.isBounce) me.setBounce(false);\n\n    if (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\n    me.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\n\n    // 在页面中加入上拉布局\n    me.upwarp = document.createElement('div');\n    me.upwarp.className = me.optUp.warpClass;\n    var upparent;\n    if (me.optUp.warpId) upparent = me.getDomById(me.optUp.warpId);\n    if (!upparent) upparent = me.scrollDom;\n    upparent.appendChild(me.upwarp);\n\n    // 滚动监听\n    me.preScrollY = 0;\n    me.lazyStartTime = new Date().getTime();// 懒加载的初始间隔时间\n    me.lazyTag = 'mescroll-lazying';// 懒加载时,图片正在加载的标记\n    me.scrollEvent = function () {\n      // 列表内容顶部卷去的高度(含列表边框)\n      var scrollTop = me.getScrollTop();\n\n      // 向上滑还是向下滑动\n      var isUp = scrollTop - me.preScrollY > 0;\n      me.preScrollY = scrollTop;\n\n      // 如果没有在加载中\n      if (!me.isUpScrolling && (!me.isDownScrolling || (me.isDownScrolling && me.optDown.isBoth))) {\n        // offsetheight 列表高度(内容+内边距+边框),滚动条在边框之内,所以使用clientHeight即可\n        // clientHeight 列表高度(内容+内边距),不含列表边框\n        // scrollHeight 列表内容撑开的高度\n        if (!me.optUp.isLock && me.optUp.hasNext) {\n          var toBottom = me.getScrollHeight() - me.getClientHeight() - scrollTop; // 滚动条距离底部的距离\n          if (toBottom <= me.optUp.offset && isUp) {\n            // 如果滚动条距离底部指定范围内且向上滑,则执行上拉加载回调\n            me.triggerUpScroll();\n          }\n        }\n      }\n\n      // 顶部按钮的显示隐藏\n      var optTop = me.optUp.toTop;\n      if (optTop.src || optTop.html) {\n        if (scrollTop >= optTop.offset) {\n          me.showTopBtn();\n        } else {\n          me.hideTopBtn();\n        }\n      }\n\n      // 懒加载\n      if (me.optUp.lazyLoad.use) {\n        // 节流:限制触发时间间隔\n        var curTime = new Date().getTime();\n        me.lazyTimer && clearTimeout(me.lazyTimer);\n        if (curTime - me.lazyStartTime >= me.optUp.lazyLoad.delay) {\n          me.lazyStartTime = curTime;\n          me.lazyLoad(0);// 列表刚滚动的时候,懒加载一次\n        } else {\n          me.lazyTimer = me.lazyLoad();\n        }\n      }\n\n      // 滑动监听\n      me.optUp.onScroll && me.optUp.onScroll(me, scrollTop, isUp);\n    }\n\n    if (me.isScrollBody) {\n      window.addEventListener('scroll', me.scrollEvent);\n    } else {\n      me.scrollDom.addEventListener('scroll', me.scrollEvent);\n    }\n\n    // 初始化完毕的回调\n    setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\n      me.optUp.inited(me, me.upwarp);\n    }, 0)\n  }\n\n  /* 是否允许ios的Bounce; true或null为允许; false禁止bounce */\n  MeScroll.prototype.setBounce = function (isBounce) {\n    if (this.isScrollBody || !this.os.ios) return; // 不支持body为滚动区域和非ios设备\n    if (isBounce === false) {\n      this.optUp.isBounce = false; // 禁止\n      window.addEventListener('touchmove', this.bounceTouchmove, {\n        passive: false\n      });\n    } else {\n      this.optUp.isBounce = true; // 允许\n      window.removeEventListener('touchmove', this.bounceTouchmove);\n    }\n  }\n\n  /* 处理bounce的touchmove事件 */\n  MeScroll.prototype.bounceTouchmove = function (e) {\n    var me = this;\n    var el = e.target;\n    // 当前touch的元素及父元素是否要拦截touchmove事件\n    var isPrevent = true;\n    while (el !== document.body && el !== document) {\n      var cls = el.classList;\n      if (cls) {\n        if (cls.contains('mescroll') || cls.contains('mescroll-touch')) {\n          isPrevent = false; // 如果是指定条件的元素,则无需拦截touchmove事件\n          break;\n        } else if (cls.contains('mescroll-touch-x') || cls.contains('mescroll-touch-y')) {\n          // 如果配置了水平或者垂直滑动\n          var curX = e.touches ? e.touches[0].pageX : e.clientX; // 当前第一个手指距离列表顶部的距离x\n          var curY = e.touches ? e.touches[0].pageY : e.clientY; // 当前第一个手指距离列表顶部的距离y\n\n          if (!me.preWinX) me.preWinX = curX; // 设置上次移动的距离x\n          if (!me.preWinY) me.preWinY = curY; // 设置上次移动的距离y\n\n          // 计算两点之间的角度\n          var x = Math.abs(me.preWinX - curX);\n          var y = Math.abs(me.preWinY - curY);\n          var z = Math.sqrt(x * x + y * y);\n\n          me.preWinX = curX; // 记录本次curX的值\n          me.preWinY = curY; // 记录本次curY的值\n\n          if (z !== 0) {\n            var angle = Math.asin(y / z) / Math.PI * 180; // 角度区间 [0,90]\n            if ((angle <= 45 && cls.contains('mescroll-touch-x')) || (angle > 45 && cls.contains('mescroll-touch-y'))) {\n              isPrevent = false; // 水平滑动或者垂直滑动,不拦截touchmove事件\n              break;\n            }\n          }\n        }\n      }\n      el = el.parentNode; // 继续检查其父元素\n    }\n\n    // 拦截touchmove事件:是否可以被禁用&&是否已经被禁用 (这里不使用me.preventDefault(e)的方法,因为某些情况下会报找不到方法的异常)\n    if (isPrevent && e.cancelable && !e.defaultPrevented && typeof e.preventDefault === \"function\") e.preventDefault();\n  }\n\n  /* 触发上拉加载 */\n  MeScroll.prototype.triggerUpScroll = function () {\n    if (this.optUp.callback && !this.isUpScrolling) {\n      this.showUpScroll(); // 上拉加载中...\n      this.optUp.page.num++; // 预先加一页,如果失败则减回\n      this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n      this.optUp.callback(this.optUp.page, this); // 执行回调,联网加载数据\n    }\n  }\n\n  /* 显示上拉加载中 */\n  MeScroll.prototype.showUpScroll = function () {\n    this.isUpScrolling = true; // 标记上拉加载中\n    this.upwarp.classList.add(this.optUp.hardwareClass); // 添加硬件加速样式,使动画更流畅\n    this.upwarp.style.visibility = 'visible'; // 显示上拉加载区域\n    this.upwarp.style.display = 'block'; // 显示上拉加载区域\n    this.optUp.showLoading(this, this.upwarp); // 加载中...\n  }\n\n  /* 显示上拉无更多数据 */\n  MeScroll.prototype.showNoMore = function () {\n    this.upwarp.style.visibility = 'visible'; // 显示上拉加载区域\n    this.upwarp.style.display = 'block'; // 显示上拉加载区域\n    this.optUp.hasNext = false; // 无更多数据\n    this.optUp.showNoMore(this, this.upwarp); // 无更多数据\n  }\n\n  /* 隐藏上拉区域. displayAble: 是否通过display:none隐藏, 默认false通过visibility:hidden的方式隐藏**/\n  MeScroll.prototype.hideUpScroll = function (displayAble) {\n    if (displayAble) {\n      this.upwarp.style.display = 'none'; // 通过display:none隐藏: 优点隐藏后不占位,缺点列表快速滑动到底部不能及时显示加载中\n    } else {\n      this.upwarp.style.visibility = 'hidden'; // 通过visibility:hidden的方式隐藏,优点当列表快速滑动到底部能及时显示加载中,缺点隐藏后会占位\n    }\n    this.upwarp.classList.remove(this.optUp.hardwareClass); // 移除硬件加速样式\n    var upProgressDom = this.upwarp.getElementsByClassName('upwarp-progress')[0];\n    if (upProgressDom) upProgressDom.classList.remove('mescroll-rotate');\n  }\n\n  /* 结束上拉加载 */\n  MeScroll.prototype.endUpScroll = function (isShowNoMore, displayAble) {\n    if (isShowNoMore != null) { // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\n      if (isShowNoMore) {\n        this.showNoMore(); // isShowNoMore=true,显示无更多数据\n      } else {\n        this.hideUpScroll(displayAble); // isShowNoMore=false,隐藏上拉加载\n      }\n    }\n    this.isUpScrolling = false; // 标记结束上拉加载\n  }\n\n  /* 重置上拉加载列表为第一页\n     *isShowLoading 是否显示进度布局;\n     * 1.默认null,不传参,则显示上拉加载的进度布局\n     * 2.传参true, 则显示下拉刷新的进度布局\n     * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\n     */\n  MeScroll.prototype.resetUpScroll = function (isShowLoading) {\n    if (this.optUp && this.optUp.use) {\n      var page = this.optUp.page;\n      this.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\n      this.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\n      page.num = 1; // 重置为第一页\n      page.time = null; // 重置时间为空\n      if (!this.isDownScrolling && isShowLoading !== false) { // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\n        if (isShowLoading == null) {\n          this.removeEmpty(); // 移除空布局\n          this.clearDataList(); // 先清空列表数据,才能显示到上拉加载的布局\n          this.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\n        } else {\n          this.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\n        }\n      }\n      this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\n      this.optUp.callback && this.optUp.callback(page, this); // 执行上拉回调\n    }\n  }\n\n  /* 设置page.num的值 */\n  MeScroll.prototype.setPageNum = function (num) {\n    this.optUp.page.num = num - 1;\n  }\n\n  /* 设置page.size的值 */\n  MeScroll.prototype.setPageSize = function (size) {\n    this.optUp.page.size = size;\n  }\n\n  /* 清空上拉加载的数据列表 */\n  MeScroll.prototype.clearDataList = function () {\n    var listId = this.optUp.clearId || this.optUp.clearEmptyId; // 优先使用clearId\n    if (listId) {\n      var listDom = this.getDomById(listId);\n      if (listDom) listDom.innerHTML = '';\n    }\n  }\n\n  /* 联网回调成功,结束下拉刷新和上拉加载\n     * dataSize: 当前页的数据量(必传)\n     * totalPage: 总页数(必传)\n     * systime: 服务器时间 (可空)\n     */\n  MeScroll.prototype.endByPage = function (dataSize, totalPage, systime) {\n    var hasNext;\n    if (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\n    this.endSuccess(dataSize, hasNext, systime);\n  }\n\n  /* 联网回调成功,结束下拉刷新和上拉加载\n     * dataSize: 当前页的数据量(必传)\n     * totalSize: 列表所有数据总数量(必传)\n     * systime: 服务器时间 (可空)\n     */\n  MeScroll.prototype.endBySize = function (dataSize, totalSize, systime) {\n    var hasNext;\n    if (this.optUp.use && totalSize != null) {\n      var loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\n      hasNext = loadSize < totalSize; // 是否还有下一页\n    }\n    this.endSuccess(dataSize, hasNext, systime);\n  }\n\n  /* 联网回调成功,结束下拉刷新和上拉加载\n     * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\n     * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\n     * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\n     */\n  MeScroll.prototype.endSuccess = function (dataSize, hasNext, systime) {\n    var me = this;\n    // 结束下拉刷新\n    if (me.isDownScrolling) me.endDownScroll();\n\n    // 结束上拉加载\n    if (me.optUp.use) {\n      var isShowNoMore; // 是否已无更多数据\n      if (dataSize != null) {\n        var pageNum = me.optUp.page.num; // 当前页码\n        var pageSize = me.optUp.page.size; // 每页长度\n        // 如果是第一页\n        if (pageNum === 1) {\n          me.clearDataList(); // 自动清空第一页列表数据\n          if (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\n        }\n        if (dataSize < pageSize || hasNext === false) {\n          // 返回的数据不满一页时,则说明已无更多数据\n          me.optUp.hasNext = false;\n          if (dataSize === 0 && pageNum === 1) {\n            // 如果第一页无任何数据且配置了空布局\n            isShowNoMore = false;\n            me.showEmpty();\n          } else {\n            // 总列表数少于配置的数量,则不显示无更多数据\n            var allDataSize = (pageNum - 1) * pageSize + dataSize;\n            if (allDataSize < me.optUp.noMoreSize) {\n              isShowNoMore = false;\n            } else {\n              isShowNoMore = true;\n            }\n            me.removeEmpty(); // 移除空布局\n          }\n        } else {\n          // 还有下一页\n          isShowNoMore = false;\n          me.optUp.hasNext = true;\n          me.removeEmpty(); // 移除空布局\n        }\n      }\n\n      // 隐藏上拉\n      var displayAble = !me.optUp.hasNext; // 没有下一页且少于noMoreSize,则以display:none的方式隐藏上拉布局\n      me.endUpScroll(isShowNoMore, displayAble);\n\n      // 检查是否满屏自动加载下一页\n      me.loadFull();\n\n      // 懒加载\n      me.optUp.lazyLoad.use && me.lazyLoad();\n    }\n  }\n\n  /* 回调失败,结束下拉刷新和上拉加载 */\n  MeScroll.prototype.endErr = function () {\n    // 结束下拉,回调失败重置回原来的页码和时间\n    if (this.isDownScrolling) {\n      var page = this.optUp.page;\n      if (page && this.prePageNum) {\n        page.num = this.prePageNum;\n        page.time = this.prePageTime;\n      }\n      this.endDownScroll();\n    }\n    // 结束上拉,回调失败重置回原来的页码\n    if (this.isUpScrolling) {\n      this.optUp.page.num--;\n      this.endUpScroll(false);\n    }\n  }\n\n  /* 检查如果加载的数据过少,无法触发上拉加载时,则自动加载下一页,直到满屏或者没有更多数据\n     此方法最好在列表的数据加载完成之后调用,以便计算列表内容高度的准确性 */\n  MeScroll.prototype.loadFull = function () {\n    var me = this;\n    if (me.optUp.loadFull.use && !me.optUp.isLock && me.optUp.hasNext && me.optUp.callback && me.getScrollHeight() <= me.getClientHeight()) {\n      setTimeout(function () {\n        // 延时之后,还需再判断一下高度,因为可能有些图片在延时期间加载完毕撑开高度\n        if (me.getScrollHeight() <= me.getClientHeight()) me.triggerUpScroll();\n      }, me.optUp.loadFull.delay)\n    }\n  }\n\n  /* 锁定上拉加载:isLock=ture,null锁定;isLock=false解锁 */\n  MeScroll.prototype.lockUpScroll = function (isLock) {\n    if (isLock == null) isLock = true;\n    this.optUp.isLock = isLock;\n  }\n\n  /* --------无任何数据的空布局-------- */\n  MeScroll.prototype.showEmpty = function () {\n    var me = this;\n    var optEmpty = me.optUp.empty; // 空布局的配置\n    var warpId = optEmpty.warpId || me.optUp.clearEmptyId; // 优先使用warpId\n    if (warpId == null) return;\n    var emptyWarp = me.getDomById(warpId) // 要显示空布局的位置\n    if (emptyWarp) {\n      me.removeEmpty(); // 先移除,避免重复加入\n      // 初始化无任何数据的空布局\n      var str = '';\n      if (optEmpty.icon) str += '<img class=\"empty-icon\" src=\"' + optEmpty.icon + '\"/>'; // 图标\n      if (optEmpty.tip) str += '<p class=\"empty-tip\">' + optEmpty.tip + '</p>'; // 提示\n      if (optEmpty.btntext) str += '<p class=\"empty-btn\">' + optEmpty.btntext + '</p>'; // 按钮\n      me.emptyDom = document.createElement('div');\n      me.emptyDom.className = 'mescroll-empty';\n      me.emptyDom.innerHTML = str;\n      emptyWarp.appendChild(me.emptyDom);\n      if (optEmpty.btnClick) { // 点击按钮的回调\n        var emptyBtn = me.emptyDom.getElementsByClassName('empty-btn')[0];\n        if (optEmpty.supportTap) {\n          emptyBtn.addEventListener('tap', function (e) {\n            e.stopPropagation();\n            me.preventDefault(e)\n            optEmpty.btnClick();\n          })\n        } else {\n          emptyBtn.onclick = function () {\n            optEmpty.btnClick();\n          }\n        }\n      }\n    }\n  }\n  /* 移除空布局 */\n  MeScroll.prototype.removeEmpty = function () {\n    this.removeChild(this.emptyDom);\n  }\n\n  /* --------回到顶部的按钮-------- */\n  MeScroll.prototype.showTopBtn = function (fadeDuration) {\n    if (!this.topBtnShow) {\n      this.topBtnShow = true; // 标记显示\n      var me = this;\n      var optTop = me.optUp.toTop; // 回到顶部的配置\n      if (me.toTopBtn == null) {\n        // 未加入按钮,则加入\n        if (optTop.html) {\n          me.toTopBtn = document.createElement('div');\n          me.toTopBtn.innerHTML = optTop.html;\n        } else {\n          me.toTopBtn = document.createElement('img');\n          me.toTopBtn.src = optTop.src;\n        }\n        me.toTopBtn.className = optTop.warpClass;\n        if (optTop.supportTap) {\n          me.toTopBtn.addEventListener('tap', function (e) {\n            e.stopPropagation();\n            me.preventDefault(e);\n            var disToTop = optTop.btnClick && optTop.btnClick(); // 执行回调\n            if (disToTop !== true) { // 如果回调里return true,将不执行回到顶部操作\n              me.scrollTo(0, me.optUp.toTop.duration); // 置顶\n            }\n          })\n        } else {\n          me.toTopBtn.onclick = function () {\n            var disToTop = optTop.btnClick && optTop.btnClick(); // 执行回调\n            if (disToTop !== true) { // 如果回调里return true,将不执行回到顶部操作\n              me.scrollTo(0, me.optUp.toTop.duration); // 置顶\n            }\n          }\n        }\n        var warpDom; // 是否配置父布局\n        if (optTop.warpId) warpDom = me.getDomById(optTop.warpId);\n        if (!warpDom) warpDom = document.body;\n        warpDom.appendChild(me.toTopBtn);\n      }\n      // 显示--淡入动画\n      me.toTopBtn.classList.remove(optTop.hideClass);\n      me.toTopBtn.classList.add(optTop.showClass);\n      me.setTopBtnFadeDuration(fadeDuration);\n    }\n  }\n  /* 隐藏回到顶部的按钮 */\n  MeScroll.prototype.hideTopBtn = function (fadeDuration) {\n    if (this.topBtnShow && this.toTopBtn) {\n      this.topBtnShow = false;\n      this.toTopBtn.classList.remove(this.optUp.toTop.showClass);\n      this.toTopBtn.classList.add(this.optUp.toTop.hideClass);\n      this.setTopBtnFadeDuration(fadeDuration);\n    }\n  }\n  /* 设置回到顶部按钮的显示隐藏动画时长,默认0.5秒 */\n  MeScroll.prototype.setTopBtnFadeDuration = function (fadeDuration) {\n    if (this.toTopBtn) {\n      var duration = (fadeDuration != null ? fadeDuration : this.optUp.toTop.fadeDuration) + 's';\n      this.toTopBtn.style.animationDuration = duration;\n      this.toTopBtn.style.webkitAnimationDuration = duration;\n    }\n  }\n\n  /* 滑动列表到指定位置--带缓冲效果 (y=0回到顶部;如果要滚动到底部可以传一个较大的值,比如99999);t时长,单位ms,默认300 */\n  MeScroll.prototype.scrollTo = function (y, t) {\n    var me = this;\n    var star = me.getScrollTop();\n    var end = y;\n    if (end > 0) {\n      var maxY = me.getScrollHeight() - me.getClientHeight(); // y的最大值\n      if (end > maxY) end = maxY; // 不可超过最大值\n    } else {\n      end = 0; // 不可小于0\n    }\n    me.isScrollTo = true; // 标记在滑动中,阻止列表的触摸事件\n    me.scrollDom.style.webkitOverflowScrolling = 'auto';\n    me.getStep(star, end, function (step) {\n      me.setScrollTop(step);\n      if (step === end) {\n        me.scrollDom.style.webkitOverflowScrolling = 'touch';\n        me.isScrollTo = false;\n      }\n    }, t)\n  }\n\n  /* 计步器\n     star: 开始值\n     end: 结束值\n     callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\n     t: 计步时长,传0则直接回调end值;不传则默认300ms\n     rate: 周期;不传则默认30ms计步一次\n     * */\n  MeScroll.prototype.getStep = function (star, end, callback, t, rate) {\n    var diff = end - star; // 差值\n    if (t === 0 || diff === 0) {\n      callback && callback(end);\n      return;\n    }\n    t = t || 300; // 时长 300ms\n    rate = rate || 30; // 周期 30ms\n    var count = t / rate; // 次数\n    var step = diff / count; // 步长\n    var i = 0; // 计数\n    var timer = window.setInterval(function () {\n      if (i < count - 1) {\n        star += step;\n        callback && callback(star, timer);\n        i++;\n      } else {\n        callback && callback(end, timer); // 最后一次直接设置end,避免计算误差\n        window.clearInterval(timer);\n      }\n    }, rate);\n  }\n\n  /* 加载可视区域的图片 */\n  MeScroll.prototype.lazyLoad = function (delay) {\n    var me = this;\n    var t = delay != null ? delay : me.optUp.lazyLoad.delay; // delay需支持传0,不使用短路求值\n    var timer = setTimeout(function () {\n      var domArr = me.scrollDom.querySelectorAll('[' + me.optUp.lazyLoad.attr + ']');\n      var len = domArr.length;\n      for (var i = 0; i < len; i++) {\n        var dom = domArr[i];\n        if (dom.getAttribute(me.lazyTag) !== 'true' && me.isInSee(dom, me.optUp.lazyLoad.offset)) {\n          var imgurl = dom.getAttribute(me.optUp.lazyLoad.attr);\n          // 采用临时img标签加载网络图: 1.不影响占位图; 2.成功可设置渐变动画; 3.失败后可重新触发加载;\n          var temp = new Image();\n          temp.onload = function () {\n            var imgurl = this.src;// 需通过this取值\n            var dom = this.dom;\n            var showClass = me.optUp.lazyLoad.showClass;// 渐变动画\n            showClass && dom.classList.add(showClass);\n            if (dom.tagName === 'IMG') {\n              dom.src = imgurl;// 如果是img标签,则直接设置src\n            } else {\n              dom.style.backgroundImage = 'url(' + imgurl + ')';// 如果其他标签,则直接设置背景\n            }\n            dom.removeAttribute(me.optUp.lazyLoad.attr);\n            dom.removeAttribute(me.lazyTag);\n          }\n          temp.onerror = function () {\n            this.dom.removeAttribute(me.lazyTag);// 失败的时候取消加载中的标记\n          }\n          temp.onabort = function () {\n            this.dom.removeAttribute(me.lazyTag);// 失败的时候取消加载中的标记\n          }\n          temp.src = imgurl;\n          // 标记在加载中..\n          dom.setAttribute(me.lazyTag, 'true');\n          // 把dom挂载到temp,确保在for循环的temp.onload能够正确取到对应的dom\n          temp.dom = dom;\n        }\n      }\n    }, t)\n    return timer;\n  }\n\n  /* 判断元素是否在列表垂直区域可视 (不考虑scrollLeft的情况,因为没法监听每个div的水平滚动事件,也不考虑translateY的情况,因为情况比较少,且会增加计算的复杂度) */\n  MeScroll.prototype.isInSee = function (dom, offset) {\n    offset = offset || 0; // 可视区域上下偏移的距离\n    var topDom = this.getOffsetTop(dom);// 元素顶部到容器顶部的距离\n    var topSee = this.getScrollTop() - offset;// 滚动条的位置(可视范围的顶部)\n    var bottomDom = topDom + dom.offsetHeight;// 元素底部到容器顶部的距离\n    var bottomSee = topSee + offset + this.getClientHeight() + offset;// 滚动条的位置+容器高度(可视范围的底部)\n    // 图片顶部在可视范围内 || 图片底部在可视范围 ; 不考虑scrollLeft和translateY的情况\n    return (topDom < bottomSee && topDom >= topSee) || (bottomDom <= bottomSee && bottomDom > topSee);\n  }\n\n  /* 获取元素到mescroll滚动列表顶部的距离 */\n  MeScroll.prototype.getOffsetTop = function (dom) {\n    var top = dom.offsetTop;\n    var parent = dom.offsetParent;\n    while (parent != null && parent !== this.scrollDom) {\n      top += parent.offsetTop + parent.clientTop;\n      parent = parent.offsetParent;\n    }\n    return top;\n  }\n\n  /* 滚动内容的高度 */\n  MeScroll.prototype.getScrollHeight = function () {\n    return this.scrollDom.scrollHeight;\n  }\n\n  /* 滚动容器的高度 */\n  MeScroll.prototype.getClientHeight = function () {\n    if (this.isScrollBody && document.compatMode === 'CSS1Compat') {\n      return document.documentElement.clientHeight;\n    } else {\n      return this.scrollDom.clientHeight;\n    }\n  }\n\n  /* body的高度 */\n  MeScroll.prototype.getBodyHeight = function () {\n    return document.body.clientHeight || document.documentElement.clientHeight;\n  }\n\n  /* 滚动条的位置 */\n  MeScroll.prototype.getScrollTop = function () {\n    if (this.isScrollBody) {\n      return document.documentElement.scrollTop || document.body.scrollTop;\n    } else {\n      return this.scrollDom.scrollTop;\n    }\n  }\n\n  /* 滚动条到底部的距离 */\n  MeScroll.prototype.getToBottom = function () {\n    return this.getScrollHeight() - this.getClientHeight() - this.getScrollTop();\n  }\n\n  /* 设置滚动条的位置 */\n  MeScroll.prototype.setScrollTop = function (y) {\n    if (typeof y === 'number') {\n      if (this.isScrollBody) {\n        document.documentElement.scrollTop = y;\n        document.body.scrollTop = y;\n      } else {\n        this.scrollDom.scrollTop = y;\n      }\n    }\n  }\n\n  /* 查找dom元素 */\n  MeScroll.prototype.getDomById = function (id) {\n    var dom;\n    if (id) {\n      if (typeof id === 'string') {\n        dom = document.getElementById(id); // 如果是String,则根据id查找\n      } else if (id.nodeType) {\n        dom = id; // 如果是dom对象,则直接赋值\n      }\n    }\n    if (!dom) console.error('the element with id as \"' + id + '\" can not be found: document.getElementById(\"' + id + '\")==null');\n    return dom;\n  }\n\n  /* 删除dom元素 */\n  MeScroll.prototype.removeChild = function (dom) {\n    if (dom) {\n      var parent = dom.parentNode;\n      parent && parent.removeChild(dom);\n      dom = null;\n    }\n  }\n\n  /* 销毁mescroll */\n  MeScroll.prototype.destroy = function () {\n    var me = this;\n\n    // 移除下拉布局,移除事件\n    me.scrollDom.removeEventListener('touchstart', me.touchstartEvent); // 移动端手指事件\n    me.scrollDom.removeEventListener('touchmove', me.touchmoveEvent); // 移动端手指事件\n    me.scrollDom.removeEventListener('touchend', me.touchendEvent); // 移动端手指事件\n    me.scrollDom.removeEventListener('touchcancel', me.touchendEvent); // 移动端手指事件\n    me.scrollDom.removeEventListener('mousedown', me.touchstartEvent); // PC端鼠标事件\n    me.scrollDom.removeEventListener('mousemove', me.touchmoveEvent); // PC端鼠标事件\n    me.scrollDom.removeEventListener('mouseup', me.touchendEvent); // PC端鼠标抬起事件\n    me.scrollDom.removeEventListener('mouseleave', me.touchendEvent); // PC端鼠标离开事件\n    me.removeChild(me.downwarp); // 下拉布局\n\n    // 移除上拉布局,回到顶部按钮,移除事件\n    if (me.isScrollBody) {\n      window.removeEventListener('scroll', me.scrollEvent); // window的滚动事件\n    } else {\n      me.scrollDom.removeEventListener('scroll', me.scrollEvent); // div的滚动事件\n    }\n    me.removeChild(me.upwarp); // 上拉布局\n    me.removeChild(me.toTopBtn); // 回到顶部按钮\n\n    // 允许回弹,解除禁止webview的touchmove事件\n    me.setBounce(true);\n  }\n\n  return MeScroll;\n});\n"],"sourceRoot":""}